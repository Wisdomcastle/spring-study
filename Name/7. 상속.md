
# 상속
> 부모가 자식에게 물려주는 행위

* 부모 클래스의 필드와 메소드를 자식 클래스에게 물려줄수있다.
* 중복코드줄여 -> 개발시간 단축
* 클래스 수정 최소화 (부모 클래스를 수정하면 모든 자식 클래스에 수정효과)
* 필드와 메소드를 4개 작성하는 것보다는 부모 클래스에서 상속받고 추가 작성하는 것이 효율적이다.

### 클래스 상속
* 현실과 다르게 자식이 부모를 선택
* 자식 클래스를 선언할때 어떤 부모로부터 상속받을 것인지 결정

```
public class 자식클래스 extends 부모클래스 {}
```

* 다중 상속은 허용하지 않음 (extends 뒤에는 단 하나의 부모 클래스만 와야함)

### 부모 생성자 호출
* 부모객체가 먼저 생성된 다음에 자식 객체 생성

```
자식클래스 변수 = new 자식클래스();
```

* 모든 객체는 생성자를 호출해야만 생성된다 -> 부모객체도 마찬가지
* 부모 생성자는 자식 생성자의 맨 첫 줄에 숨겨져있는 super()에 의해 호출된다.

```
public 자식클래스(...){
    super(); //부모의 기본 생성자 호출
    ...
}
```
### 메소드 재정의(=메소드 오버라이딩)
* 부모의 내용이 자식과 맞지않을경우 메소드를 재정의하여 수정 
>상속된 메소드를 자식 클래스에서 재정의하는 것

* 메소드가 오버라이팅 되었다면 해당 부모 메소드는 숨겨지고, 자식 메소드가 우선적으로 사용된다.
* @overried : 재정의한 것이 정확히 정의되었는지 컴파일러가 확안 -> 어노테이션

1. 부모 메소드의 선언부(리턴 타입, 메소드 이름, 매개변수)와 동일해야한다.
2. 접근 제한을 더 강하게 오버라이딩할 수 없다(public -> private로 변경불가)
3. 새로운 예외를 throws 할 수 없다.

### 부모 메소드 호출
* 자식 메소드 내에서 super 키워드와 도트 연산자를 사용해 숨겨진 부모 메소드를 호출할 수 있다.
* 부모 메소드를 재사용함으로써 자식 메소드의 중복 작업 내용을 없앤다.

### final 클래스와 final 메소드
* final : 클래스 선언할때 class 앞에 붙이면 최종적 클래스로 더이상 상속 불가능
* 즉, final 클래스는 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없다.

### protected 접근 제한자
* 상속과 관련있고, public과 default의 중간쯤 위치
* 같은 페키지에서 default처럼 접근 가능하나 다른 패키지에서는 자식 클래스만 접근 허용
* 필드, 생성자, 메소드 선언데 사용될 수 있다. 
* 클래스가 동일 패키지에 있는 경우 필드, 생성자, 메소드에 접근 가능

### 자동 타입 변환
* 클래스의 타입 변환은 상속 관계에 있는 클래스 사이에서 발생한다.
```
부모타입 변수 = 자식타입객체;      -> 자동 타입변환
```
* 바로 위 부모가 아니라도 상속 계층에서 상위 타입이면 자동 타입 변환이 일어날 수 있다.
* 예를들어 고양이가 동물의 특징과 기능을 상속받았다면 '고양이는 동물이다'가 성립한다.
* 부모 타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근 가능하다.
* 변수는 자식 객체를 참조하지만 변수로 접근 가능한 멤버는 부모 클래스 멤버로 한정된다.

### 강제 타입 변환
* 부모 타입은 자식 타입으로 자동 변환되지 않는다.
* 캐스팅 연산자로 강제 타입 변환 가능하다.
```
자식타입 변수 = (자식타입) 부모타입객체;
```
* 여기서 (자식타입)이 캐스팅 연산자이다.
* 무조건 강제 변환가능한 것이 아닌 자식 객체가 부모 타입으로 자동 변환된 후 다시 자식 타입으로 변환할 때 강제 타입 변환을 사용할 수 있다.
![](../../../../image/무제 폴더/6EC55A48-837C-4E64-9173-5C9088DC52CB.jpeg)

### 다형성
> 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질
* 자동차의 부품을 교환하면 성능이 달라지듯이 객체를 바꾸면 프로그램의 실행 성능이 다르게 나올 수 있다.
* 객체 사용 방법이 동일하다는 것은 동일한 메소드를 가지고 있다는 것이다.
* 다형성을 구현하기 위해서는 자동 타입 변환과 메소드 재정의가 필요하다. 
* 필드 다형성 : 필드 타입은 동일하지만, 대입되는 객체가 달라서 실행결과가 다양하게 나올 수 있는 것
* 매개변수 다형성 : 매개변수의 타입이 클래스인 경우, 해당 클래스의 객체뿐만 아니라 자식 객체까지도 매개값으로 사용할 수 있다.

### 객체 타입 확인
```
boolean result = 객체 instanceof 타입;
```
* instanceof 연산자 좌항에는 객체가 우항에는 타입이 오는데, 좌항의 객체가 우항의 타입이면 true를 그렇지 않으면 false를 산출한다.
* 상속 관계가 아니면 비교불가하다.

### 추상 클래스
> 객체를 생성할 수 있는 클래스를 실체 클래스라고 한다면 이 클래스들의 공통적인 필드나 메소드를 추출해 선언한 클래스를 추상 클래스라고 한다.
* 실체 클래스의 공통되는 필드와 메소드를 추출해서 만들었기 때문에 new 연산자를 사용해서 객체를 직접 생성할 수 없다.
* 새로운 실체 클래스를 만들기 위한 부모 클래스로만 사용된다. 추상클래스는 extends 뒤에만 올 수 있다.
```lombok.config
public abstract class 클래스명 {
    //필드
    //생성자
    //메소드
}
```
* 자식 객체가 생성될때 super()로 추상 클래스의 생성자가 호출되기 때문에 생성자도 반드시 있어야 한다.

### 추상 메소드와 재정의
```
abstract 리턴타입 메소드명(매개변수, ...);
```
* 자식 클래스들이 가지고 있는 공통 메소드를 뽑아내 추상클래스 작성할때, 메소드 선언부만 동일하고 실행내용은 자식 클래스마다 달라야하는 경우가 많다.
* Animal 추상 클래스에서 sound()라는 메소드를 선언할 수 있지만 실행 내용인 소리는 동물마다 달라 추상 클래스에서 통일해 작성할 수 없다.
* 추상 메소드는 자식 클래스에서 반드시 재정의해서 실행 내용을 채워야 한다.